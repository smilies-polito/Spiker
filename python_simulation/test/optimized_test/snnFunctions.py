#!/Users/alessio/anaconda3/bin/python3

import sys

development = "/Users/alessio/Documents/Poli/Magistrale/Tesi/\
Tesi/spiker/python_simulation/development/optimized_test"

if development not in sys.path:
	sys.path.insert(1,development)

from snn import snn
from neuronFunctions import createArray
from layerFunctions import createDictList, \
			storeMembranePotentials, \
			plotLayerResults
import numpy as np


# Simulate the network. The function loops over all the layers in the network and
# updates both the membrane potentials and the events generated by each neuron in each
# layer, storing their temporal evolution inside proper arrays.
#
# INPUT PARAMETERS:
#
# 	1) N_sim: desired number of simulation cycles.
#
# 	2) inEvents_evolution: bidimensional NumPy array which contains on each
# 	   row the input events provided to the network at each simulation step. 
# 	   The rows represent the temporal evolution of these events.
#
# 	3) networkDictList: list of lists of dictionaries containing the parameters of the
# 	   neurons in the various layers
#
# 	4) dt_tau: ratio delta_t/tau., See the function "neuron" for more details.
#
# 	5) outEvents_evolution: preallocated tridimensional NumPy array that will
# 	   be filled with the temporal evolution of the output of each layer. Each entry
# 	   of the array will correspond to the events of all the layer in a single time
# 	   step. Before the plot the array will need to be transposed. In particular
# 	   axis 0 and 2 must be switched.
#
# 	6) v_mem_evolution: preallocated tridimensional NumPy array that will
# 	   be filled with the temporal evolution of the membrane potential of each layer. 
# 	   Each entry of the array will correspond to the events of all the layer in a
# 	   single time step. Before the plot the array will need to be transposed. 
# 	   In particular axis 0 and 2 must be switched.
#
# 	7) layersList: list of integer numbers which describes the network. Each entry of
# 	   the list represents a layer. The number corresponding to the layer represents
# 	   the number of nodes inside the layer.

def simulateSnn(N_sim, inEvents_evolution, networkDictList, dt_tau, outEventsEvol_list,
		v_memEvol_list, layersList):


	# Create list of NumPy arrays to store the output events in the each simulation
	# step
	outEvents_list = [np.zeros(layersList[i]).astype(bool) for i in 
				range(1, len(layersList))] 

	for i in range(N_sim):

		# Update the entire network
		snn(inEvents_evolution[i], networkDictList, dt_tau, outEvents_list,
			layersList)

		# Store the temporal evolution of the membrane potentials
		storeNetworkPotentials(networkDictList, v_memEvol_list, i)


		# Store the temporal evolution of the output events
		storeOutputEvolution(outEvents_list, outEventsEvol_list, i)
	




# Create a list of lists dictionaries containing a list for each layer. Each list
# contains the dictionaries with the parameters of each neuron.
#
# INPUT PARAMETERS:
#
# 	1) layersList: list which describes the net. It contains one entry for each layer.
# 	   Each entry is an integer number which represents the number of nodes in the
# 	   layer. It is important that this list includes also the the input layer. This
# 	   will not be translated in a physical layer of neurons but it is needed to
# 	   dimension the weight array of the first layer.
#
# 	2) v_th_list, v_res_list, w_min_list and w_max_list: lists of NumPy arrays 
# 	   containing the desired parameters of each neuron. 
#
# See createNeuronDict for more details on the input parameters.

def createNetworkDictList(layersList, v_th_list, v_res_list, w_min_list, w_max_list):

	return [createDictList(layersList[i], v_th_list[i-1], v_res_list[i-1], layersList[i-1],
		w_min_list[i-1], w_max_list[i-1]) for i in range(1, len(layersList))]



# Create a list of bidimensional arrays. This can be used to store the temporal
# evolution of the output or the membrane potetnial of each layer.
#
# INPUT PARAMETERS:
# 
# 	1) layersList: list which contains the description of the network. Each entry is
# 	   an integer number associated to one layer and corresponding to the mnumber of
# 	   neurons inside the layer.
#
# 	2) N_sim: number of desired simulation cycles.

def createArraysList(layersList, N_sim):

	return [createArray(N_sim,layersList[i]) for i in range(1, len(layersList))]



# Add the elements contained in a list of NumPy arrays to all the elements of a
# list of bidimensional arrays, at a specific index. It can be used to store the
# current values of the output events generated by each layer at a specific index
# of the temporal evolution of the output events.
#
# INPUT PARAMENTERS:
#
# 	1) outEvents_list: list containing the output events of the current step,
# 	   stored in form of NumPy arrays
#
# 	2) outEventsEvol_lis: list containing bidimensional NumPy arrays which
# 	   correspond to the temporal evolution of the output events.
#
# 	3) currentStep: index of the current temporal iteration. This is needed
# 	   to store the output events in the right position.

def storeOutputEvolution(outEvents_list, outEventsEvol_list, currentStep):

	for i in range(len(outEvents_list)):

		outEventsEvol_list[i][currentStep] = outEvents_list[i]






# Add the membrane potential of each neuron to the array that corresponds to its
# layer and that contains the temporal evolution of the membrane potential of each
# neuron in the layer.
#
# INPUT PARAMETERS:
#
# 	1) networkDictList: list of lists of dictionaries. Each dictionary contains
# 	   the parameters of the specific neuron.
#
# 	2) v_memEvol_list: list of bidimensional NumPy arrays. Each array contains
# 	   the temporal evolution of the output events of the specific layer.
#
# 	3) currentStep: current simulation step. Needed to store the values of the
# 	   output events in the correct position.

def storeNetworkPotentials(networkDictList, v_memEvol_list, currentStep):

	for i in range(len(networkDictList)):

		storeMembranePotentials(len(networkDictList[i]), networkDictList[i], 
					v_memEvol_list[i][currentStep])



# Plot the results of each neuron in the network.
#
# INPUT PARAMETERS:
#
# 	1) layersList: list which describes the net. It contains one entry for each layer.
# 	   Each entry is an integer number which represents the number of nodes in the
# 	   layer. It is important that this list includes also the the input layer in
# 	   order to properly organize the plots.
#
# 	2) inEvents_evolution: bidimensional NumPy array containing the
# 	   temporal evolution of the input events coming from the previous layer.
# 	   The events are the same for each neuron, being the network fully
# 	   connected.
#
# 	3) outEventsEvol_list, v_memEvol_list: list of bidimensional NumPy arrays
# 	   containing the temporal evolution of the output events and the membrane 
# 	   potential for each neuron in each layer. The arrays stored in the list are 
# 	   expected to be ordered in the same way in which the functions storeOutputEvolution
# 	   and storeNetworkPotentials stored them. This means that each row corresponds
# 	   to a simulation step and contains the values of the output or the membrane
# 	   potential for each neuron in the layer. In order to correctly plot them
# 	   the arrays need to be transposed. In this way each row contains the temporal
# 	   evolution of a specific neuron in the layer. For this reason the function
# 	   transpose each array before plotting it.
#
# 	4) v_th_list: list of NumPy arrays containing the value of the threshold for each
#	   neuron.
#
# See plotLayerResults for more details on the input parameters.

def plotNetworkResults(layersList, inEvents_evolution, outEventsEvol_list, 
			v_memEvol_list, v_th_list):


	outEventsEvol_list[0] = outEventsEvol_list[0].T
	v_memEvol_list[0] = v_memEvol_list[0].T

	plotLayerResults(layersList[1], layersList[0], inEvents_evolution,
				outEventsEvol_list[0], v_memEvol_list[0], v_th_list[0])

	for i in range(1, len(layersList)-1):

		# Transpose the arrays in order to obtain the temporal evolution of
		# each neuron
		outEventsEvol_list[i] = outEventsEvol_list[i].T
		v_memEvol_list[i] = v_memEvol_list[i].T

		plotLayerResults(layersList[i+1], layersList[i], outEventsEvol_list[i-1],
				outEventsEvol_list[i], v_memEvol_list[i], v_th_list[i])
