import numpy as np

from poisson import *

from equationsParameters import *
from neuronsParameters import *

# Add the parameters of the network to the local variables
locals().update(parametersDict)




def run(network, networkList, constSum, trainDuration, currentSpikesCount, 
	prevSpikesCount):

	"""
	Train the network over the pixels spikes trains.

	INPUT:

		1) network: Brian2 Network object containing the complete
		network structure.

		2) networkList: list of integer numbers. Each element of the 
		list corresponds to a layer and identifies the number of nodes
		in that layer.

		3) constSum: float. Normalization factor for the weights.

		4) trainDuration: time duration of the spikes train expressed in
		milleseconds.

		5) currentSpikesCount: NumPy array with size equal to the number
		of elements in the last layer. 

		6) prevSpikesCount: NumPy array containing the count of the
		spikes generated by the network up to the previous training
		cycle.
	"""

	# Train the network over the pixels" spikes train
	network.run(trainDuration)
	
	# Update the count of the spikes generated by the network
	updatePulsesCount(network, currentSpikesCount, prevSpikesCount)

	# Normalize the weights
	normalizeNetWeights(network, networkList, constSum)	





def updatePulsesCount(network, currentSpikesCount, prevSpikesCount):

	"""
	Update the count of the spikes generated along a training cycle over a
	complete train of spikes.

	INPUT:

		1) network: Brian2 Network object containing the complete
		network structure.

		2) currentSpikesCount: NumPy array with size equal to the number
		of elements in the last layer. 

		3) prevSpikesCount: NumPy array containing the count of the
		spikes generated by the network up to the previous training
		cycle.

	"""

	# Get the total spikes" count from the beginnning up to now.
	spikeMonitorCount = network.get_states(
				units=True, 
				format="dict", 
				subexpressions=False, 
				read_only_variables=True,
				level=0)["spikemonitor"]["count"]

	# Compute the spikes" count relative to the current image
	currentSpikesCount[:] = np.asarray(spikeMonitorCount) - prevSpikesCount
	
	# Update the total count
	prevSpikesCount[:] = np.asarray(spikeMonitorCount)





def normalizeNetWeights(network, networkList, constSum):

	"""
	Normalize the weights of all the layers in the network.

	INPUT:

		1) network: Brian2 Network object containing the complete
		network structure.

		2) networkList: list of integer numbers. Each element of the 
		list corresponds to a layer and identifies the number of nodes
		in that layer.

		3) constSum: float. Normalization factor for the weights.
	"""

	for i in range(1, len(networkList)):

		# Normalize the weights of the current synapses
		normalizeLayerWeights(network, "exc2exc" + str(i),
				networkList[i-1], networkList[i], constSum)






def normalizeLayerWeights(network, connectionName, inputLayerSize, excLayerSize,
			constSum):

	"""
	Normalize the weights of the given layer.

	INPUT:

		1) network:  Brian2 Network object containing the complete
		network structure.

		2) connectionName: string reporting the name of the connection.
		The standard name is "poisson2exc" or "exc2exc" + the index of
		the layer.

		3) inputLayerSize: number of elements of the input layer.

		4) excLayerSize: number of elements of the current excitatory
		layer.

		5) constSum: constant value corresponding to the sum of all the
		weights of a single neuron.

	"""

	# Read the current values of the netework"s states
	connection = network.get_states()

	# Select the weights of the desired connection and normalize them
	newWeights = normalizeWeights(connection[connectionName]["w"], 
			inputLayerSize, excLayerSize, constSum)

	# Store the weights into a proper data structure for the update
	values = {
		connectionName : {
			"w" : newWeights
		}
	}

	# Update the values of the weights
	network.set_states(values)

	




def normalizeWeights(weightsArray, inputLayerSize, excLayerSize, constSum):

	"""
	Normalize the values of the input array weightsArray.

	INPUT:

		1) weightsArray: NumPy array containing the values to normalize.

		2) inputLayerSize: number of elements of the input layer.

		3) excLayerSize: number of elements of the current excitatory
		layer.

		4) constSum: constant value corresponding to the sum of all the
		weights of a single neuron.

	OUTPUT:
		normalized array.
	"""

	# Reshape the array in order to have one sub-array for each neuron
	newWeights = np.reshape(weightsArray, (inputLayerSize, excLayerSize))

	# Compute the sum of the weights for each neuron
	normFactors = newWeights.sum(axis=0)

	# Set to one the zero sums to avoid division by 0
	normFactors[normFactors == 0] = 1

	# Compute the normalization factor
	normFactors = constSum/normFactors

	# Normalize the weights
	newWeights = newWeights*normFactors

	# Give to the array the starting shape
	return np.reshape(newWeights, inputLayerSize*excLayerSize)
