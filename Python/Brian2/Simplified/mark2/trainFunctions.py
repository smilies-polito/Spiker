import brian2 as b2
import timeit
import numpy as np
import sys


from poisson import *
from common import *

from equationsParameters import *
from neuronsParameters import *

# Add the parameters of the network to the local variables
locals().update(parametersDict)



def singleImageTraining(trainDuration, restTime, image, network, networkList, 
		currentSpikesCount, prevSpikesCount, countThreshold,
		inputIntensity, currentIndex, spikesEvolution, updateInterval,
		printInterval, startTimeTraining, accuracies, labelsArray,
		assignments, startInputIntensity, mode, constSum):

	'''
	Train the network over an image of the dataset.

	INPUT:

		1) trainDuration: time duration of the spikes train expressed in
		milleseconds.

		2) restTime: time duration of the resting period expressed in
		milliseconds.

		3) image: NumPy array containing the value of each pixel
		expressed as an integer.

		4) network: Brian2 Network object containing the complete
		network structure.

		5) networkList: list of integer numbers. Each element of the 
		list corresponds to a layer and identifies the number of nodes
		in that layer.

		6) currentSpikesCount: NumPy array with size equal to the number
		of elements in the last layer. 

		7) prevSpikesCount: NumPy array containing the count of the
		spikes generated by the network up to the previous training
		cycle.

		8) countThreshold: minimum acceptable number of output spikes
		generated during the training.

		9) inputIntensity: current value of the pixel's intensity.

		10) currentIndex: index of the current image.

		11) spikesEvolution: two-dimensional NumPy array containing the
		history of the spikes counter in the last "updateInterval"
		cycles. One row for each training step. One column for each
		element in the output layer.

		12) updateInterval: number of images after which the performance
		is computed.

		13) printInterval: number of images after which the progress
		message is printed. 

		14) startTimeTraining: system time corresponfing to the beginning
		of the training.

		15) accuracies: list of strings containing the history of the
		accuracy.

		16) labelsArray: NumPy array containing all the labels of the
		training set.

		17) assignments: NumPy array containing one label assignment for
		each output neuron.

		18) startInputIntensity: starting value of the pixel's intensity.
		The default value is 2.

		19) mode: string. It can be "train" or "test".

		20) constSums: NumPy array. Each element represents the constant
		value corresponding to the sum of all the weights of a single 
		neuron in the specific layer.

	
	OUTPUT:

		1) inputIntensity: update value of the pixel's intensity.

		2) currentIndex: index of the next image to analyse.

		3) accuracies: updated list of strings containing the history of 
		the accuracy.

	'''


	# Measure the system time corresponding to the beginning of the image
	startTimeImage = timeit.default_timer()

	# Convert the image into spikes trains
	imgToSpikeTrain(network, image, inputIntensity)
	
	# Train the network with the spikes sequences associated to the pixels.
	inputIntensity, currentIndex, accuracies = \
		train(
			network, 
			networkList, 
			trainDuration,
			countThreshold,
			inputIntensity,
			currentIndex,
			spikesEvolution,
			updateInterval,
			printInterval,
			startTimeImage,
			startTimeTraining,
			accuracies,
			labelsArray,
			assignments,
			startInputIntensity,
			mode,
			currentSpikesCount,
			prevSpikesCount
		)


	# Normalize the weights
	normalizeNetWeights(network, networkList, constSum)	

	# Bring the network into a rest state
	rest(network, restTime, image.shape[0])

	return inputIntensity, currentIndex, accuracies





	

def train(network, networkList, trainDuration, countThreshold, inputIntensity,
		currentIndex, spikesEvolution, updateInterval, printInterval,
		startTimeImage, startTimeTraining, accuracies, labelsArray,
		assignments, startInputIntensity, mode, currentSpikesCount,
		prevSpikesCount):

	'''
	Train the network with the spikes sequences associated to the pixels.

	INPUT:

		1) network: Brian2 Network object containing the complete
		network structure.

		2) networkList: list of integer numbers. Each element of the 
		list corresponds to a layer and identifies the number of nodes
		in that layer.

		3) spikesTrains: time duration of the spikes trains expressed
		in milliseconds.

		4) countThreshold: minimum acceptable number of output spikes
		generated during the training.

		5) inputIntensity: current value of the pixel's intensity.

		6) currentIndex: index of the current image.

		7) spikesEvolution: two-dimensional NumPy array containing the
		history of the spikes counter in the last "updateInterval"
		cycles. One row for each training step. One column for each
		element in the output layer.

		8) updateInterval: number of images after which the performance
		is computed.

		9) printInterval: number of images after which the progress
		message is printed. 

		10) startTimeImage: system time corresponding to the beginning of
		the image.

		11) startTimeTraining: system time corresponfing to the beginning
		of the training.

		12) accuracies: list of strings containing the history of the
		accuracy.

		13) labelsArray: NumPy array containing all the labels of the
		training set.

		14) assignments: NumPy array containing one label assignment for
		each output neuron.

		15) startInputIntensity: starting value of the pixel's intensity.
		The default value is 2.

		16) mode: string. It can be "train" or "test".

		17) currentSpikesCount: NumPy array with size equal to the number
		of elements in the last layer. 

		18) prevSpikesCount: NumPy array containing the count of the
		spikes generated by the network up to the previous training
		cycle.




	OUTPUT:

		1) inputIntensity: update value of the pixel's intensity.

		2) currentIndex: index of the next image to analyse.

		3) accuracies: updated list of strings containing the history of 
		the accuracy.


	'''

	# Train the network over the pixels' spikes train
	network.run(trainDuration)
	
	# Update the count of the spikes generated by the network
	updatePulsesCount(network, currentSpikesCount, prevSpikesCount)


	if np.sum(currentSpikesCount) < countThreshold:

		# Prepare the training over the same image
		inputIntensity = repeatImage(inputIntensity, currentIndex)

	else:

		# Prepare the training over the next image
		inputIntensity, currentIndex, accuracies = \
			nextImage(
				networkList, 
				spikesEvolution, 
				updateInterval, 
				printInterval, 
				currentSpikesCount, 
				startTimeImage,
				startTimeTraining, 
				accuracies, 
				labelsArray, 
				assignments, 
				startInputIntensity, 
				currentIndex, 
				mode)

	return inputIntensity, currentIndex, accuracies






def normalizeNetWeights(network, networkList, constSum):

	'''
	Normalize the weights of all the layers in the network.

	INPUT:

		1) network: Brian2 Network object containing the complete
		network structure.

		2) networkList: list of integer numbers. Each element of the 
		list corresponds to a layer and identifies the number of nodes
		in that layer.

		3) constSums: NumPy array. Each element represents the constant
		value corresponding to the sum of all the weights of a single 
		neuron in the specific layer.
		
	'''

	# Normalize the weights of the input synapses
	normalizeLayerWeights(network, "poisson2exc", networkList[0],
				networkList[1], constSum)

	for i in range(2, len(networkList)):

		# Normalize the weights of the current synapses
		normalizeLayerWeights(network, "exc2exc" + str(i-1),
				networkList[i-1], networkList[i], constSum)






def normalizeLayerWeights(network, connectionName, inputLayerSize, excLayerSize,
			constSum):

	'''
	Normalize the weights of the given layer.

	INPUT:

		1) network:  Brian2 Network object containing the complete
		network structure.

		2) connectionName: string reporting the name of the connection.
		The standard name is "poisson2exc" or "exc2exc" + the index of
		the layer.

		3) inputLayerSize: number of elements of the input layer.

		4) excLayerSize: number of elements of the current excitatory
		layer.

		5) constSum: constant value corresponding to the sum of all the
		weights of a single neuron.

	'''

	# Read the current values of the netework's states
	connection = network.get_states()

	# Select the weights of the desired connection and normalize them
	newWeights = normalizeWeights(connection[connectionName]["w"], 
			inputLayerSize, excLayerSize, constSum)

	# Store the weights into a proper data structure for the update
	values = {
		connectionName : {
			"w" : newWeights
		}
	}

	# Update the values of the weights
	network.set_states(values)

	




def normalizeWeights(weightsArray, inputLayerSize, excLayerSize, constSum):

	'''
	Normalize the values of the input array weightsArray.

	INPUT:

		1) weightsArray: NumPy array containing the values to normalize.

		2) inputLayerSize: number of elements of the input layer.

		3) excLayerSize: number of elements of the current excitatory
		layer.

		4) constSum: constant value corresponding to the sum of all the
		weights of a single neuron.

	OUTPUT:
		normalized array.
	'''

	# Make a copy of the array to normalize
	newWeights = np.copy(weightsArray)

	# Reshape the array in order to have one sub-array for eac neuron
	newWeights = np.reshape(newWeights, (inputLayerSize, excLayerSize))

	# Compute the sum of the weights for each neuron
	normFactors = newWeights.sum(axis=0)

	# Set to one the zero sums to avoid division by 0
	normFactors[normFactors == 0] = 1

	# Compute the normalization factor
	normFactors = constSum/normFactors

	# Normalize the weights
	newWeights = newWeights*normFactors

	# Give to the array the starting shape
	return np.reshape(newWeights, inputLayerSize*excLayerSize)
