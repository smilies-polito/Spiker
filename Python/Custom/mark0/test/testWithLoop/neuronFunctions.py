#!/Users/alessio/anaconda3/bin/python3

import sys

development = "/Users/alessio/Documents/Poli/Magistrale/Tesi/\
Tesi/spiker/python/custom/mark0/development/testWithLoop"

if development not in sys.path:
	sys.path.insert(1,development)


import numpy as np
import scipy.sparse as sp
from neuron import neuron
import matplotlib.pyplot as plt


# Create the dictionary that contains all the parameters of the neuron.
#
# INPUT PARAMETERS:
#
# 	1) v_th: value of the firing threshold
#
# 	2) v_res: reset voltage. When the membrane potential is reset, this
# 	   is the value that it assumes.
#
# 	3) prevLayerDim: dimension of the previous layer, needed to
# 	   initialize the weights of the neuron.
#
# 	4) w_min, w_max: minimum and maximum ends of the range in which the
# 	   coefficients must be generated.

def createNeuronDict(v_th, v_res, prevLayerDim, w_min, w_max):
	
	# Random generator
	rng = np.random.default_rng()

	neuronDict = {}

	# Initialize the neuron's parameters
	neuronDict["v_th"] = v_th
	neuronDict["v_mem"] = v_res
	neuronDict["weights"] = (w_max-w_min)*rng.random(size=prevLayerDim)\
					+ w_min

	return neuronDict





# Create a sparse bidimensional array. This can be used to create the input
# spikes that will be provided to the network
#
# INPUT PARAMETERS:
#
# 	1) N_sim: number of simulation cycles
#
# 	2) prevLayerDim: dimension of the previous layer
#
#	3) density: density of spikes in the whole bidimensional
#	   array
#
# The function returns a N_sim x prevLayerDim NumPy array

def createSparseArray(N_sim, prevLayerDim, density):
	
	# Create a spare matrix of random values
	sparseArray = sp.random(N_sim, prevLayerDim, density = density)

	# Convert the values inside the matrix to boolean type
	sparseArray = sparseArray.A.astype(bool)

	return sparseArray




# Preallocate a generic bidimensional array. This can be used to preallocate
# the arrays of output events and membrane potential in order to make the
# simulation faster.
# 
# INPUT PARAMETERS:
#
# 	1) N_sim: number of simulation cycles
#
# 	2) currLayerDim

def createArray(N_sim, currLayerDim):
	return np.zeros((N_sim, currLayerDim))






# Simulate the neuron. The function simply update the neuron for a number
# of times coincident with the desired number of simulation cycles

def simulateNeuron(N_sim, inEvents, outEvents, v_mem_evolution, neuronDict, dt_tau):

	for i in range(N_sim):
		outEvents[i] = neuron(inEvents[i], neuronDict, dt_tau)
		v_mem_evolution[i] = neuronDict["v_mem"]




# Function to plot input events, membrane potential and output events of a 
# neuron on a single plot organized in subplots
#
# INPUT PARAMETERS:
#
# 	1) prevLayerDim: number of neurons in the previous layer. This is
# 	   needed to dimension the number of subplots. They need to be
# 	   prevLayerDim + 2 in order to include also the subplots of the
# 	   membrane potential and of the output events.
#
# 	2) inEvents: NumPy bidimensional array containing the temporal
# 	   evolution of the spikes generated by each neuron in the previous
# 	   layer.
#
# 	3) outEvents: NumPy array which contains the temporal evolution of
# 	   the events generated by the current neuron.
#
# 	4) v_mem_evolution: NumPy array which contains the temporal evolution
# 	   of the membrane potential.
#
# 	5) v_th: firing threshold. It will be represented with a dashed line
# 	   together with the membrane potential in order to clearly visualize
# 	   when the threshold is exceeded.

def plotResults(prevLayerDim, inEvents, outEvents, v_mem_evolution, v_th):

	fig, axs = plt.subplots(prevLayerDim+2, 1)

	# Plot the input events
	subplotMultipleArrays(axs, inEvents, "Input Spikes")

	# Plot the membrane potential and the threshold
	subplotArrayAndConst(axs[prevLayerDim], v_mem_evolution, "Membrane Potential", v_th)

	# Plot the output events
	subplotArray(axs[prevLayerDim+1], outEvents, "Output Spikes")

	# Increase the spacing between subplots
	plt.subplots_adjust(hspace = 1.5)

	# Show the plot
	plt.show()






# Plot a generic array on a subplot.
#
# INPUT PARAMETERS:
#
# 	1) axs: subplot object on which the array will be plotted. This must
# 	   have been previously created using matplotlib.pyplot.subplots()
# 	   function.
#
# 	2) plotData: NumPy array containing the values to plot
#
# 	3) title: string which contains the title to assign to the plot

def subplotArray(axs, plotData, title):

	axs.plot(plotData)
	axs.grid()
	axs.set_xticks(np.arange(0, plotData.size, 
			step = plotData.size/20))
	axs.set_title(title)






# Plot the desired number of arrays on an equivalent number of subplots.
#
# INPUT PARAMETERS:
#
# 	1) axs: subplot object on which the arrays will be plotted. This must
# 	   have been previously created using matplotlib.pyplot.subplots()
# 	   function with dimensions that are consistent with the number of
# 	   subplots needed
#
# 	2) plotData: NumPy bidimensional array containing all the arrays to plot
#
# 	3) title: string which contains the generic title of the group of
# 	   subplots

def subplotMultipleArrays(axs, plotData, title):

	# Compute the total amount of subplots
	N_subplots = plotData.T[0].size

	axs[0].set_title(title)

	for i in range(N_subplots):
		axs[i].plot(plotData[i])
		axs[i].grid()
		axs[i].set_xticks(np.arange(0, plotData[i].size, 
				step = plotData[i].size/20))




	
# Plot a generic array on a subplot together with a constant dashed line
#
# INPUT PARAMETERS:
#
# 	1) axs: subplot object on which the array will be plotted. This must
# 	   have been previously created using matplotlib.pyplot.subplots()
# 	   function.
#
# 	2) plotData: NumPy array containing the values to plot
#
# 	3) title: string which contains the title to assign to the plot
#
# 	4) constValue: value that will be plot together with the array

def subplotArrayAndConst(axs, plotData, title, constValue):

	constValue = constValue*np.ones(plotData.size)

	axs.plot(plotData)
	axs.plot(constValue, "--")
	axs.grid()
	axs.set_xticks(np.arange(0, plotData.size, 
			step = plotData.size/20))
	axs.set_title(title)
